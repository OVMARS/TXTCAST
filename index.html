<script>
  const display = document.getElementById('memoDisplay');
  const status = document.getElementById('status');
  const cursor = document.querySelector('.cursor');
  let isFetching = false; // prevent overlapping fetches

  const connection = new solanaWeb3.Connection(
    solanaWeb3.clusterApiUrl("mainnet-beta"),
    "confirmed"
  );

  const walletAddress = new solanaWeb3.PublicKey("9Er7ydwgEXhun5L2mHmmcjBP5qUxLYFF44PuQttNo2Sx");

  async function fetchTXTCASTMemos() {
    const limit = 100;
    let beforeSig = null;
    const memos = [];
    const seen = new Set();
    try {
      while (true) {
        const options = { limit };
        if (beforeSig) options.before = beforeSig;
        const signatures = await connection.getSignaturesForAddress(walletAddress, options);
        if (!signatures.length) break;
        beforeSig = signatures[signatures.length - 1].signature;

        for (let sig of signatures) {
          const tx = await connection.getParsedTransaction(sig.signature, { commitment: "confirmed" });
          if (!tx?.transaction?.message) continue;

          const allInstructions = [
            ...(tx.transaction.message.instructions || []),
            ...((tx.meta?.innerInstructions || []).flatMap(i => i.instructions) || [])
          ];

          for (let ix of allInstructions) {
            let data = "";
            if (ix.parsed && ix.parsed.type === "memo") {
              data = ix.parsed.info.memo || "";
            } else {
              try {
                data = ix.data ? atob(ix.data) : "";
              } catch (e) {
                try {
                  data = new TextDecoder().decode(new Uint8Array(ix.data));
                } catch (_) {}
              }
            }

            if (/^TXTCAST/.test(data) && !seen.has(data)) {
              memos.push(data.trim());
              seen.add(data.trim());
            }
          }
        }

        if (signatures.length < limit) break;
      }
      console.log("Fetched memos:", memos); // for debugging
      return memos.reverse();
    } catch (err) {
      status.textContent = `❌ Error fetching memos: ${err}`;
      return [];
    }
  }

  async function displayMemos() {
    if (isFetching) return; // Prevent overlap
    isFetching = true;
    status.textContent = "🔄 Loading TXTCAST memos...";
    const memos = await fetchTXTCASTMemos();
    if (!memos.length) {
      display.innerHTML = "No TXTCAST memos found.<span class='cursor'></span>";
      status.textContent = "✅ Connected — No TXTCAST memos yet.";
      isFetching = false;
      return;
    }

    let index = 0;
    status.textContent = `✅ Showing ${memos.length} TXTCAST memo(s).`;

    async function typeMemo(text) {
      display.innerHTML = ""; // Clear previous text
      for (let i = 0; i < text.length; i++) {
        display.innerHTML += text[i];
        display.appendChild(cursor);
        await new Promise(r => setTimeout(r, 25));
      }
    }

    async function loop() {
      while (index < memos.length) {
        await typeMemo(memos[index]);
        await new Promise(r => setTimeout(r, 5000));
        index++;
      }
      isFetching = false; // Mark fetch complete after loop
    }

    loop();
  }

  displayMemos();
  setInterval(displayMemos, 90000);
</script>
