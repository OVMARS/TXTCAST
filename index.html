<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TXTCAST FEED</title>
  <script src="https://unpkg.com/@solana/web3.js@1.75.1/lib/index.iife.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
  <style>
    body { background: #000; margin: 0; padding: 0; font-family: 'Fira Code', monospace; color: #0f0; }
    .wrapper { max-width: 800px; margin: 3em auto; background: #111; padding: 2em; border-radius: 12px; box-shadow: 0 0 20px #0f03; }
    h1 { font-size: 1.8em; color: #fff; text-align: center; margin-bottom: 1em; }
    .memo-box { background: #000; padding: 1em; border-radius: 8px; border: 1px solid #333; height: 260px; overflow-y: auto; font-size: 14px; white-space: pre-wrap; word-wrap: break-word; line-height: 1.4; }
    .cursor { display: inline-block; width: 6px; animation: blink 0.8s infinite; background: #0f0; height: 1em; vertical-align: bottom; }
    @keyframes blink { 50% { opacity: 0; } }
    .status { color: #888; font-size: 12px; margin-top: 1em; text-align: center; }
    /* Added warning style from my previous version, can be removed if not desired */
    .rpc-warning { color: #f80; font-size: 10px; text-align: center; margin-top: 5px; height: 12px; }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>ðŸ“¡ TXTCAST Viewer</h1>
    <div class="memo-box" id="memoDisplay">Initializing...<span class="cursor"></span></div>
    <div class="status" id="status">Connecting to Solana RPC...</div>
    <div class="rpc-warning" id="rpcWarningMessage"></div> <!-- For RPC specific warnings -->
  </div>

  <script>
    // --- Configuration ---
    const HELIUS_PUBLIC_EXAMPLE_KEY = "34ea16bb-80b2-4e57-ad72-e94ecda7028a";
    const CORRECT_MEMO_PROGRAM_ID = "MemoSq4gqABAXKb96qnH8TysNcVtrp5GcC9YGN9qET9";

    // Using the Helius public example key as the primary, as requested.
    const RPC_URLS = [
      `https://mainnet.helius-rpc.com/?api-key=${HELIUS_PUBLIC_EXAMPLE_KEY}`,
      "https://api.mainnet-beta.solana.com", // Fallback
    ];
    // Helius Transaction History API base (using the same public example key)
    const HELIUS_HISTORY_API_BASE = "https://api.helius.xyz/v0/addresses/";


    const WALLET_ADDRESS = "9Er7ydwgEXhun5L2mHmmcjBP5qUxLYFF44PuQttNo2Sx";
    const FETCH_LIMIT = 50;
    const MAX_TRANSACTIONS_TO_SCAN = 500;
    const TYPING_SPEED_MS = 20;
    const MEMO_DISPLAY_DURATION_MS = 7000;
    const REFRESH_INTERVAL_MS = 120000; // 2 minutes

    let rpcIndex = 0;
    let walletPublicKey; // Will be initialized after solanaWeb3 is loaded
    let display;
    let statusDisplay;
    let rpcWarningDisplay;
    let cursorElement;

    let currentMemos = [];
    let currentMemoIndex = 0;
    let isTyping = false;
    let displayCycleTimeoutId = null;

    // Function to initialize DOM elements once the script is sure they exist
    function initializeDOMElements() {
        display = document.getElementById('memoDisplay');
        statusDisplay = document.getElementById('status');
        rpcWarningDisplay = document.getElementById('rpcWarningMessage');
        cursorElement = document.createElement('span');
        cursorElement.className = 'cursor';

        if (!display || !statusDisplay || !rpcWarningDisplay) {
            console.error("CRITICAL: UI DOM elements not found. Display will not work.");
            // Potentially display an error message directly on the body
            document.body.innerHTML = "<h1 style='color:red; text-align:center;'>Critical Error: UI Elements Missing. Check Console.</h1>";
            return false;
        }
        return true;
    }


    function getApiKeyFromUrl(rpcUrl) {
        try {
            const url = new URL(rpcUrl);
            return url.searchParams.get("api-key");
        } catch (e) { return null; }
    }

    const getConnection = () => {
        const activeRpcUrl = RPC_URLS[rpcIndex % RPC_URLS.length];
        if (rpcWarningDisplay) { // Check if display element exists
            if (getApiKeyFromUrl(activeRpcUrl) === HELIUS_PUBLIC_EXAMPLE_KEY) {
                rpcWarningDisplay.textContent = "Using Helius public example API key. May be rate-limited.";
            } else {
                rpcWarningDisplay.textContent = "";
            }
        }
        return new solanaWeb3.Connection(activeRpcUrl, "confirmed");
    };

    function extractMemoFromInstruction(ix) {
        let memoData = "";
        if (ix.program === "spl-memo") {
            if (ix.parsed && typeof ix.parsed === 'object' && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
                memoData = ix.parsed.info.memo;
            } else if (typeof ix.parsed === 'string') {
                memoData = ix.parsed;
            }
        } else if (!ix.program && ix.parsed && typeof ix.parsed === 'object' && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
            memoData = ix.parsed.info.memo;
        } else if (ix.programId && ix.programId.toString() === CORRECT_MEMO_PROGRAM_ID && typeof ix.data === 'string') {
            try {
                memoData = new TextDecoder().decode(solanaWeb3.utils.bytes.bs58.decode(ix.data));
            } catch (e) { console.warn("Error decoding raw SPL Memo data:", e.message); }
        }
        return memoData.trim();
    }

    async function fetchTXTCASTMemosViaHeliusHistoryAPI(apiKey, currentBeforeSig) {
        // Note: The Helius transaction history API URL for a specific address is different from the one for multiple transactions.
        // The one you provided `https://api.helius.xyz/v0/transactions/` is for specific tx signatures.
        // The one for address history is `https://api.helius.xyz/v0/addresses/{address}/transactions/`
        const heliusApiUrlForAddress = `${HELIUS_HISTORY_API_BASE}${WALLET_ADDRESS}/transactions/`;
        let queryParams = `?api-key=${apiKey}&limit=${FETCH_LIMIT}`;
        // Helius API has 'type' not 'transaction-type'. Let's try without type filter first for broader results.
        // queryParams += `&type=ANY`; // Or be more specific e.g. type=TRANSFER&type=UNKNOWN (for memos)
        if (currentBeforeSig) {
            queryParams += `&before=${currentBeforeSig}`;
        }
        const fullUrl = heliusApiUrlForAddress + queryParams;
        console.log(`[HeliusHistoryAPI] Fetching: ${fullUrl.replace(apiKey, "YOUR_KEY")}`);

        try {
            const response = await fetch(fullUrl);
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`[HeliusHistoryAPI] Error: ${response.status}. Response: ${errorText}`);
                throw new Error(`Helius History API request failed: ${response.status}`);
            }
            const transactions = await response.json();
            if (!Array.isArray(transactions)) {
                console.error("[HeliusHistoryAPI] Did not return an array:", transactions);
                return { newMemos: [], lastSignature: currentBeforeSig, hasMore: false };
            }

            const memosFound = new Set();
            let lastTxSignatureInBatch = null;

            for (const tx of transactions) {
                if (!tx || !tx.signature) continue;
                lastTxSignatureInBatch = tx.signature;

                if (tx.description && /^TXTCAST/i.test(tx.description.trim())) {
                    memosFound.add(tx.description.trim());
                    continue;
                }
                
                const instructionsToScan = [];
                // Helius v0 enriched transactions have `instructions` at the top level
                if (tx.instructions) instructionsToScan.push(...tx.instructions);
                // Also check `transaction.message.instructions` if the above is not present or different
                else if (tx.transaction?.message?.instructions) instructionsToScan.push(...tx.transaction.message.instructions);


                for (const ix of instructionsToScan) {
                    // Helius v0 `instructions` are already quite parsed.
                    // We need to adapt `extractMemoFromInstruction` or use Helius-specific fields.
                    let memo = "";
                    if (ix.programId === CORRECT_MEMO_PROGRAM_ID || (ix.accounts && ix.accounts.includes(CORRECT_MEMO_PROGRAM_ID))) { // Heuristic
                        // Helius might put memo data directly in ix.data (need to verify if it's base64/utf8)
                        // or in a more structured way if it parses the memo instruction itself.
                        // For Helius parsed structure, look for something like:
                        // ix.actions[j].type === "MEMO" -> ix.actions[j].info.memo
                        // Or if ix.data is the raw memo string (less likely directly in Helius v0 parsed instruction)
                        if (ix.data && typeof ix.data === 'string') { // Assuming Helius might put it here if not further parsed.
                             try { memo = new TextDecoder().decode(solanaWeb3.utils.bytes.bs58.decode(ix.data)); } catch(_){}
                        }
                        // If Helius fully parses it (check example response from Helius API explorer):
                        if (ix.parsed && typeof ix.parsed === 'string') { // Our known case
                            memo = ix.parsed;
                        } else if (ix.parsed && ix.parsed.info && ix.parsed.info.memo) {
                            memo = ix.parsed.info.memo;
                        }
                    }
                     if (!memo) memo = extractMemoFromInstruction(ix); // Try generic extraction

                    if (memo && /^TXTCAST/i.test(memo.trim())) {
                        memosFound.add(memo.trim());
                        break;
                    }
                }
            }
            return {
                newMemos: Array.from(memosFound),
                lastSignature: lastTxSignatureInBatch,
                hasMore: transactions.length === FETCH_LIMIT
            };
        } catch (error) {
            console.error("[HeliusHistoryAPI] Fetch/Parse Error:", error.message);
            if (apiKey === HELIUS_PUBLIC_EXAMPLE_KEY && (String(error).includes("401") || String(error).includes("403") || String(error).includes("429"))) {
                 console.warn("[HeliusHistoryAPI] Error with public key for Helius History API.");
            }
            throw error;
        }
    }

    async function fetchTXTCASTMemos() {
        const connection = getConnection();
        const currentRpcUrl = connection.rpcEndpoint;
        const heliusApiKey = getApiKeyFromUrl(currentRpcUrl);

        const allFetchedMemos = new Set();
        let beforeSig = null;
        let transactionsScannedThisCycle = 0;
        console.log(`[MainFetch] Starting fetch. RPC: ${currentRpcUrl.split('?')[0]}`);

        try {
            while (transactionsScannedThisCycle < MAX_TRANSACTIONS_TO_SCAN) {
                let batchMemos = [];
                let lastProcessedSigInBatch = null;
                let hasMoreInThisIteration = false;
                let batchSizeAttempt = FETCH_LIMIT;


                if (heliusApiKey && currentRpcUrl.includes("helius-rpc.com")) {
                    console.log(`[MainFetch] Attempting Helius History API.`);
                    try {
                        const heliusResult = await fetchTXTCASTMemosViaHeliusHistoryAPI(heliusApiKey, beforeSig);
                        batchMemos = heliusResult.newMemos;
                        lastProcessedSigInBatch = heliusResult.lastSignature;
                        hasMoreInThisIteration = heliusResult.hasMore;
                        batchSizeAttempt = FETCH_LIMIT; // Helius API was asked for this many
                    } catch (heliusError) {
                        console.warn("[MainFetch] Helius History API failed. Falling back to standard method.", heliusError.message);
                        batchSizeAttempt = 0; // Force standard method
                    }
                } else {
                     batchSizeAttempt = 0; // Not a Helius RPC, use standard
                }
                
                if (batchSizeAttempt === 0) { // Use standard if Helius not attempted or failed
                    console.log(`[MainFetch] Using Standard web3.js getSignatures.`);
                    const options = { limit: FETCH_LIMIT };
                    if (beforeSig) options.before = beforeSig;
                    const signaturesInfo = await connection.getSignaturesForAddress(walletPublicKey, options);

                    if (!signaturesInfo.length) { console.log("[MainFetch-Std] No more signatures."); break; }
                    
                    lastProcessedSigInBatch = signaturesInfo[signaturesInfo.length - 1].signature;
                    hasMoreInThisIteration = signaturesInfo.length === FETCH_LIMIT;
                    batchSizeAttempt = signaturesInfo.length;


                    for (const sigInfo of signaturesInfo) {
                        const tx = await connection.getParsedTransaction(sigInfo.signature, {
                            commitment: "confirmed", maxSupportedTransactionVersion: 0
                        });
                        if (!tx?.transaction?.message) continue;

                        const instructions = [
                            ...(tx.transaction.message.instructions || []),
                            ...((tx.meta?.innerInstructions || []).flatMap(i => i.instructions) || [])
                        ];
                        for (const ix of instructions) {
                            const memo = extractMemoFromInstruction(ix);
                            if (memo && /^TXTCAST/i.test(memo)) {
                                batchMemos.push(memo);
                                break; 
                            }
                        }
                    }
                }

                batchMemos.forEach(memo => allFetchedMemos.add(memo));
                transactionsScannedThisCycle += batchSizeAttempt > 0 ? batchSizeAttempt : FETCH_LIMIT;

                if (lastProcessedSigInBatch) {
                    beforeSig = lastProcessedSigInBatch;
                } else { console.log("[MainFetch] No lastProcessedSigInBatch."); break; }

                if (!hasMoreInThisIteration) { console.log("[MainFetch] No more Txs indicated by batch."); break; }
                if (transactionsScannedThisCycle >= MAX_TRANSACTIONS_TO_SCAN) { console.log("[MainFetch] Reached MAX_TRANSACTIONS_TO_SCAN."); break; }
            }
            console.log(`[MainFetch] Cycle done. Found ${allFetchedMemos.size} unique TXTCAST memos.`);
            return Array.from(allFetchedMemos).reverse(); 
        } catch (err) {
            console.error(`[MainFetch] Error with ${currentRpcUrl.split('?')[0]}:`, err.message);
            rpcIndex = (rpcIndex + 1) % RPC_URLS.length;
            if (statusDisplay) statusDisplay.textContent = `RPC Error. Trying next...`;
            await new Promise(resolve => setTimeout(resolve, 2000));
            return fetchTXTCASTMemos(); 
        }
    }

    async function typeText(element, text) {
      if (!element) return;
      element.innerHTML = "";
      for (let i = 0; i < text.length; i++) {
        element.innerHTML += text[i];
        if (cursorElement) element.appendChild(cursorElement);
        await new Promise(r => setTimeout(r, TYPING_SPEED_MS));
      }
      if (cursorElement && cursorElement.parentNode === element) {
        element.removeChild(cursorElement);
      }
    }

    async function cycleMemos() {
      if (isTyping || !display) return; // Check if display exists
      if (currentMemos.length === 0) {
        display.innerHTML = "No TXTCAST memos found to display.";
        if (cursorElement && cursorElement.parentNode === display) display.removeChild(cursorElement);
        displayCycleTimeoutId = setTimeout(cycleMemos, MEMO_DISPLAY_DURATION_MS);
        return;
      }
      isTyping = true;
      const memoToDisplay = currentMemos[currentMemoIndex];
      if (statusDisplay) statusDisplay.textContent = `ðŸ“¡ Displaying memo ${currentMemoIndex + 1} of ${currentMemos.length}`;
      
      await typeText(display, memoToDisplay);
      
      currentMemoIndex = (currentMemoIndex + 1) % currentMemos.length;
      isTyping = false;
      displayCycleTimeoutId = setTimeout(cycleMemos, MEMO_DISPLAY_DURATION_MS);
    }

    async function updateAndDisplayMemos() {
      if (!display || !statusDisplay) { // Check if display elements exist
          console.error("UI elements not ready for updateAndDisplayMemos");
          return;
      }
      console.log("[UpdateCycle] Starting updateAndDisplayMemos...");
      statusDisplay.textContent = "ðŸ”„ Fetching latest TXTCAST memos...";
      display.innerHTML = "âŒ› Loading memos...";
      if(cursorElement) display.appendChild(cursorElement);
      
      if (displayCycleTimeoutId) {
        clearTimeout(displayCycleTimeoutId);
        displayCycleTimeoutId = null;
      }

      const fetchedNewMemos = await fetchTXTCASTMemos();

      if (fetchedNewMemos && fetchedNewMemos.length > 0) {
        currentMemos = fetchedNewMemos;
        if (currentMemoIndex >= currentMemos.length) currentMemoIndex = 0;
        statusDisplay.textContent = `âœ… ${currentMemos.length} TXTCAST memos ready. Displaying...`;
      } else if (currentMemos.length === 0) {
        statusDisplay.textContent = "âœ… Connected â€” No TXTCAST memos found yet. Will retry.";
        display.innerHTML = "No TXTCAST memos found.";
        if(cursorElement && cursorElement.parentNode === display) display.removeChild(cursorElement);
      } else {
         statusDisplay.textContent = `âœ… ${currentMemos.length} memos kept. No new TXTCAST memos this cycle.`;
      }
      isTyping = false;
      cycleMemos();
    }

    // --- Initialization ---
    // Wait for the DOM to be fully loaded before trying to access elements
    document.addEventListener('DOMContentLoaded', () => {
        if (!initializeDOMElements()) {
            return; // Stop if UI elements are not found
        }

        try {
            walletPublicKey = new solanaWeb3.PublicKey(WALLET_ADDRESS);
        } catch (e) {
            console.error("Invalid Wallet Address:", WALLET_ADDRESS, e);
            statusDisplay.textContent = "ERROR: Invalid Wallet Address.";
            display.innerHTML = "Configuration Error.";
            return;
        }

        if (RPC_URLS.length === 0 || RPC_URLS.every(url => url.includes("YOUR_OWN") && !url.includes(HELIUS_PUBLIC_EXAMPLE_KEY) )) {
            statusDisplay.textContent = "ERROR: No valid custom RPC URLs configured.";
            display.innerHTML = "RPC Configuration Error.";
            if(rpcWarningDisplay) rpcWarningDisplay.textContent = "Add your Helius key in RPC_URLS for reliability.";
        } else {
            updateAndDisplayMemos();
            setInterval(updateAndDisplayMemos, REFRESH_INTERVAL_MS);
        }
    });
  </script>
</body>
</html>
