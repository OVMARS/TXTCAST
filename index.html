<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TXTCAST - Specific TX Test</title>
  <script src="https://unpkg.com/@solana/web3.js@1.75.1/lib/index.iife.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Fira Code', monospace; background: #111; color: #eee; padding: 20px; }
    pre { background: #222; padding: 15px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; }
    .success { color: #0f0; }
    .error { color: #f00; }
  </style>
</head>
<body>
  <h1>TXTCAST - Specific Transaction Test</h1>
  <div id="output">Running test...</div>

  <script>
    // --- Configuration ---
    // IMPORTANT: Use the RPC URL you were testing with in the previous simplified script.
    // Option 1: Helius example RPC (replace with your own Helius RPC key if you have one)
    const RPC_URL = "https://mainnet.helius-rpc.com/?api-key=34ea16bb-80b2-4e57-ad72-e94ecda7028a";

    // Option 2: Public Solana RPC (can be rate-limited)
    // const RPC_URL = "https://api.mainnet-beta.solana.com";

    // Option 3: Your own private/paid RPC
    // const RPC_URL = "YOUR_PRIVATE_RPC_URL_HERE";


    const TRANSACTION_SIGNATURES_TO_TEST = [
      "4ihrUYY7FEpjwH8552nCMSeqiSMN8uBXxUtnT9ecEgp3epkQMjs75rx2nZvjP37YUDcdAsdQ8AZNbgUcJqDmgZfR",
      "3qgqKLG3oKvXXVuCqKn7oVceArnX9aAdb3N1dAdLxBcEdiDbXZEVzQi3yMyhyNLtAZSZYLhLn3YAHQejSMBgsK7Y"
    ];

    const outputDiv = document.getElementById('output');

    async function testSpecificTransactions() {
      outputDiv.innerHTML = `Connecting to RPC: ${RPC_URL.split('?')[0]}...<br>`;
      const connection = new solanaWeb3.Connection(RPC_URL, "confirmed");

      for (const sig of TRANSACTION_SIGNATURES_TO_TEST) {
        outputDiv.innerHTML += `<hr>Fetching transaction: ${sig}<br>`;
        try {
          const tx = await connection.getParsedTransaction(sig, {
            commitment: "confirmed",
            maxSupportedTransactionVersion: 0
          });

          if (!tx) {
            outputDiv.innerHTML += `<span class="error">Error: Transaction data not found or null for ${sig}</span><br>`;
            console.error(`Transaction data not found or null for ${sig}`, tx);
            continue;
          }

          outputDiv.innerHTML += `Transaction fetched. Slot: ${tx.slot}<br>`;
          // console.log(`Raw TX object for ${sig}:`, JSON.parse(JSON.stringify(tx))); // Deep copy for logging

          if (!tx.transaction || !tx.transaction.message) {
            outputDiv.innerHTML += `<span class="error">Error: tx.transaction or tx.transaction.message is missing for ${sig}</span><br>`;
            console.error(`tx.transaction or tx.transaction.message is missing for ${sig}`, tx);
            continue;
          }

          outputDiv.innerHTML += `Found ${tx.transaction.message.instructions.length} top-level instructions.<br>`;
          if (tx.meta && tx.meta.innerInstructions) {
            outputDiv.innerHTML += `Found ${tx.meta.innerInstructions.length} sets of inner instructions.<br>`;
          }


          let memoFoundInTx = false;
          const instructionsToParse = [
            ...(tx.transaction.message.instructions || []),
            ...((tx.meta?.innerInstructions || []).flatMap(instrSet => instrSet.instructions) || [])
          ];

          outputDiv.innerHTML += `Total instructions to check (including inner): ${instructionsToParse.length}<br>`;

          for (let i = 0; i < instructionsToParse.length; i++) {
            const ix = instructionsToParse[i];
            outputDiv.innerHTML += `--- Checking instruction ${i + 1} ---<br>`;
            outputDiv.innerHTML += `Program ID: ${ix.programId ? ix.programId.toString() : 'N/A (likely parsed directly)'}<br>`;

            let memoData = "";

            // Check if Helius (or other RPC) already parsed it as a memo object
            if (ix.parsed && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
              memoData = ix.parsed.info.memo;
              outputDiv.innerHTML += `Found parsed memo directly: "${memoData}"<br>`;
            }
            // Check for SPL Memo Program ID and try to decode 'data'
            else if (ix.programId && ix.programId.toString() === 'MemoSq4gqABAXKb96qnH8TysNcVtrp5GcC9YGN9qET9' && ix.data) {
              outputDiv.innerHTML += `Is SPL Memo Program. Raw data (base58): ${ix.data}<br>`;
              try {
                memoData = new TextDecoder().decode(solanaWeb3.utils.bytes.bs58.decode(ix.data));
                outputDiv.innerHTML += `Decoded SPL Memo data: "${memoData}"<br>`;
              } catch (e) {
                outputDiv.innerHTML += `<span class="error">Error decoding SPL Memo data: ${e.message}</span><br>`;
                console.error("Error decoding SPL Memo data:", e, "Raw data:", ix.data);
              }
            } else {
                 outputDiv.innerHTML += `Not a directly parsed memo or recognized SPL Memo program instruction.<br>`;
                 // Log the instruction structure if it's not what we expect
                 // console.log(`Instruction ${i+1} structure for ${sig}:`, JSON.parse(JSON.stringify(ix)));
            }

            if (memoData && /^TXTCAST/i.test(memoData.trim())) {
              outputDiv.innerHTML += `<span class="success">SUCCESS: TXTCAST Found: "${memoData.trim()}"</span><br>`;
              memoFoundInTx = true;
              break; // Found it, move to next transaction
            } else if (memoData) {
              outputDiv.innerHTML += `Found a memo, but it does not start with TXTCAST: "${memoData.trim()}"<br>`;
            }
          } // end instruction loop

          if (!memoFoundInTx) {
            outputDiv.innerHTML += `<span class="error">No TXTCAST memo found in transaction ${sig} after checking all instructions.</span><br>`;
          }

        } catch (error) {
          outputDiv.innerHTML += `<span class="error">MAJOR ERROR fetching/processing transaction ${sig}: ${error.message}</span><br>`;
          console.error(`Error fetching/processing transaction ${sig}:`, error, error.stack);
           if (error.message.includes("429") || error.message.toLowerCase().includes("rate limit")) {
                outputDiv.innerHTML += `<span class="error">This was likely a RATE LIMIT error from the RPC.</span><br>`;
            }
        }
      } // end transaction loop
      outputDiv.innerHTML += "<hr>Test complete.<br>";
    }

    // Run the test
    testSpecificTransactions();
  </script>
</body>
</html>
