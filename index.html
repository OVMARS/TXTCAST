<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TXTCAST FEED</title>
  <script src="https://unpkg.com/@solana/web3.js@1.75.1/lib/index.iife.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
  <style>
    body { background: #000; margin: 0; padding: 0; font-family: 'Fira Code', monospace; color: #0f0; }
    .wrapper { max-width: 800px; margin: 3em auto; background: #111; padding: 2em; border-radius: 12px; box-shadow: 0 0 20px #0f03; }
    h1 { font-size: 1.8em; color: #fff; text-align: center; margin-bottom: 1em; }
    .memo-box { background: #000; padding: 1em; border-radius: 8px; border: 1px solid #333; height: 260px; overflow-y: auto; font-size: 14px; white-space: pre-wrap; word-wrap: break-word; line-height: 1.4; }
    .memo-item {
        padding-bottom: 0.5em;
        margin-bottom: 0.5em;
        border-bottom: 1px dashed #333; /* Separator for list items */
    }
    .memo-item:last-child {
        border-bottom: none;
    }
    /* Cursor is not used in list view, can be removed if typing effect is fully gone */
    /* .cursor { display: inline-block; width: 6px; animation: blink 0.8s infinite; background: #0f0; height: 1em; vertical-align: bottom; }
    @keyframes blink { 50% { opacity: 0; } } */
    .status { color: #888; font-size: 12px; margin-top: 1em; text-align: center; }
    .rpc-warning { display: none; /* Hide the RPC warning message as requested */ }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>ðŸ“¡ TXTCAST Viewer</h1>
    <div class="memo-box" id="memoDisplay">Initializing...</div>
    <div class="status" id="statusDisplay">Connecting to Solana RPC...</div>
    <div class="rpc-warning" id="rpcWarningMessage"></div>
  </div>

  <script>
    // --- Configuration ---
    const HELIUS_PUBLIC_EXAMPLE_KEY = "34ea16bb-80b2-4e57-ad72-e94ecda7028a";
    const CORRECT_MEMO_PROGRAM_ID = "MemoSq4gqABAXKb96qnH8TysNcVtrp5GcC9YGN9qET9";

    const RPC_URLS = [
      `https://mainnet.helius-rpc.com/?api-key=${HELIUS_PUBLIC_EXAMPLE_KEY}`,
      "https://api.mainnet-beta.solana.com", // Fallback
    ];

    const WALLET_ADDRESS = "9Er7ydwgEXhun5L2mHmmcjBP5qUxLYFF44PuQttNo2Sx";
    const FETCH_LIMIT_SIGS = 100; // How many signatures to fetch in each RPC call
    const MAX_SIGNATURE_PAGES = 5;  // Scan up to 5 pages (FETCH_LIMIT_SIGS * MAX_SIGNATURE_PAGES = 500 txs)
    const REFRESH_INTERVAL_MS = 120000; // 2 minutes

    let rpcIndex = 0;
    let walletPublicKey;
    let memoDisplayDiv;
    let statusDiv;
    // let rpcWarningDiv; // Not used if message is hidden

    let fetchedMemosList = []; // Store all fetched memos for list display

    function initializeDOMElements() {
        memoDisplayDiv = document.getElementById('memoDisplay');
        statusDiv = document.getElementById('statusDisplay');
        // rpcWarningDiv = document.getElementById('rpcWarningMessage'); // Not strictly needed if hidden

        if (!memoDisplayDiv || !statusDiv) {
            console.error("CRITICAL: UI DOM elements (memoDisplay or statusDisplay) not found.");
            document.body.innerHTML = "<h1 style='color:red; text-align:center;'>Critical Error: UI Elements Missing.</h1>";
            return false;
        }
        memoDisplayDiv.innerHTML = "Initializing..."; // Clear potential old cursor span
        return true;
    }

    const getConnection = () => {
        const activeRpcUrl = RPC_URLS[rpcIndex % RPC_URLS.length];
        // if (rpcWarningDiv) { /* Warning message logic removed as requested */ }
        console.log(`[Connection] Using RPC: ${activeRpcUrl.split('?')[0]}`);
        return new solanaWeb3.Connection(activeRpcUrl, "confirmed");
    };

    function extractMemoFromInstruction(ix) {
        let memoData = "";
        if (ix.program === "spl-memo") {
            if (ix.parsed && typeof ix.parsed === 'object' && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
                memoData = ix.parsed.info.memo;
            } else if (typeof ix.parsed === 'string') { // This was the key finding for Helius public key
                memoData = ix.parsed;
            }
        } else if (!ix.program && ix.parsed && typeof ix.parsed === 'object' && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
            memoData = ix.parsed.info.memo;
        } else if (ix.programId && ix.programId.toString() === CORRECT_MEMO_PROGRAM_ID && typeof ix.data === 'string') {
            try {
                memoData = new TextDecoder().decode(solanaWeb3.utils.bytes.bs58.decode(ix.data));
            } catch (e) { console.warn("Error decoding raw SPL Memo data:", e.message); }
        }
        return memoData.trim();
    }

    async function fetchAllTxTcastMemos() {
        if (!walletPublicKey) {
            console.error("Wallet PublicKey not initialized.");
            return [];
        }
        const connection = getConnection();
        console.log(`[FetchAll] Starting fetch for wallet: ${WALLET_ADDRESS}`);
        const allFoundMemos = new Set();
        let beforeSig = null;
        let pagesFetched = 0;

        try {
            while (pagesFetched < MAX_SIGNATURE_PAGES) {
                const options = { limit: FETCH_LIMIT_SIGS };
                if (beforeSig) options.before = beforeSig;
                
                console.log(`[FetchAll] Fetching signatures page ${pagesFetched + 1}, before: ${beforeSig || 'N/A'}`);
                const signaturesInfo = await connection.getSignaturesForAddress(walletPublicKey, options);

                if (!signaturesInfo || signaturesInfo.length === 0) {
                    console.log(`[FetchAll] No more signatures found on page ${pagesFetched + 1}.`);
                    break; 
                }
                console.log(`[FetchAll] Found ${signaturesInfo.length} signatures on page ${pagesFetched + 1}.`);

                for (let i = 0; i < signaturesInfo.length; i++) {
                    const sigInfo = signaturesInfo[i];
                    try {
                        const tx = await connection.getParsedTransaction(sigInfo.signature, {
                            commitment: "confirmed",
                            maxSupportedTransactionVersion: 0
                        });

                        if (!tx?.transaction?.message) {
                            console.warn(`[FetchAll] Could not get parsed tx for ${sigInfo.signature}`);
                            continue;
                        }

                        const instructions = [
                            ...(tx.transaction.message.instructions || []),
                            ...((tx.meta?.innerInstructions || []).flatMap(instr => instr.instructions) || [])
                        ];

                        for (const ix of instructions) {
                            const memo = extractMemoFromInstruction(ix);
                            if (memo && /^TXTCAST/i.test(memo)) {
                                console.log(`[FetchAll] TXTCAST Found: "${memo.substring(0,30)}..." in tx ${sigInfo.signature}`);
                                allFoundMemos.add(memo);
                                break; 
                            }
                        }
                    } catch (txError) {
                        console.error(`[FetchAll] Error processing transaction ${sigInfo.signature}:`, txError.message);
                        if (String(txError).toLowerCase().includes("rate limit")) {
                            console.warn("[FetchAll] Hit rate limit. Consider using a personal RPC key.");
                            // Could choose to break the inner loop or even outer loop on severe rate limiting
                        }
                    }
                }

                beforeSig = signaturesInfo[signaturesInfo.length - 1].signature;
                pagesFetched++;

                if (signaturesInfo.length < FETCH_LIMIT_SIGS) {
                    console.log("[FetchAll] Last page of signatures reached.");
                    break;
                }
            }
            const memosArray = Array.from(allFoundMemos);
            console.log(`[FetchAll] Finished. Total unique TXTCAST memos: ${memosArray.length}`);
            return memosArray.reverse(); // Show oldest first in the list typically

        } catch (error) {
            console.error(`[FetchAll] Major RPC error with ${connection.rpcEndpoint.split('?')[0]}:`, error.message);
            rpcIndex = (rpcIndex + 1) % RPC_URLS.length;
            if (statusDiv) statusDiv.textContent = `RPC Error. Trying next RPC...`;
            await new Promise(resolve => setTimeout(resolve, 3000)); // Wait longer before retrying full fetch
            return fetchAllTxTcastMemos(); // Retry with next RPC
        }
    }

    function displayMemosAsList(memos) {
        if (!memoDisplayDiv) return;
        memoDisplayDiv.innerHTML = ''; // Clear previous content

        if (!memos || memos.length === 0) {
            memoDisplayDiv.textContent = "No TXTCAST memos found to display.";
            return;
        }

        memos.forEach(memoText => {
            const memoElement = document.createElement('div');
            memoElement.className = 'memo-item';
            memoElement.textContent = memoText;
            memoDisplayDiv.appendChild(memoElement);
        });
    }

    async function updateAndDisplayMemos() {
        if (!initializeDOMElements()) return; // Ensure UI elements are ready

        console.log("[UpdateCycle] Starting update...");
        if (statusDiv) statusDiv.textContent = "ðŸ”„ Fetching latest TXTCAST memos...";
        if (memoDisplayDiv) memoDisplayDiv.innerHTML = "âŒ› Loading memos...";

        fetchedMemosList = await fetchAllTxTcastMemos(); // Update the global list

        displayMemosAsList(fetchedMemosList); // Display the fetched memos as a list

        if (statusDiv) {
            if (fetchedMemosList.length > 0) {
                statusDiv.textContent = `âœ… Displaying ${fetchedMemosList.length} TXTCAST memo(s).`;
            } else {
                statusDiv.textContent = "âœ… Connected â€” No TXTCAST memos found yet. Will retry.";
            }
        }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        if (!initializeDOMElements()) {
            return; 
        }

        try {
            walletPublicKey = new solanaWeb3.PublicKey(WALLET_ADDRESS);
        } catch (e) {
            console.error("Invalid Wallet Address:", WALLET_ADDRESS, e);
            if (statusDiv) statusDiv.textContent = "ERROR: Invalid Wallet Address.";
            if (memoDisplayDiv) memoDisplayDiv.innerHTML = "Configuration Error.";
            return;
        }

        if (RPC_URLS.length === 0) {
            if(statusDiv) statusDiv.textContent = "ERROR: No RPC URLs configured.";
            if(memoDisplayDiv) memoDisplayDiv.innerHTML = "RPC Configuration Error.";
        } else {
            updateAndDisplayMemos(); // Initial fetch and display
            setInterval(updateAndDisplayMemos, REFRESH_INTERVAL_MS); // Periodically refresh
        }
    });
  </script>
</body>
</html>
