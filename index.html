<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TXTCAST FEED - Simplified Fetch</title>
  <script src="https://unpkg.com/@solana/web3.js@1.75.1/lib/index.iife.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
  <style>
    body { background: #000; margin: 0; padding: 0; font-family: 'Fira Code', monospace; color: #0f0; }
    .wrapper { max-width: 800px; margin: 3em auto; background: #111; padding: 2em; border-radius: 12px; box-shadow: 0 0 20px #0f03; }
    h1 { font-size: 1.8em; color: #fff; text-align: center; margin-bottom: 1em; }
    .memo-box { background: #000; padding: 1em; border-radius: 8px; border: 1px solid #333; height: 260px; overflow-y: auto; font-size: 14px; white-space: pre-wrap; word-wrap: break-word; line-height: 1.4; }
    .cursor { display: inline-block; width: 6px; animation: blink 0.8s infinite; background: #0f0; height: 1em; vertical-align: bottom; }
    @keyframes blink { 50% { opacity: 0; } }
    .status { color: #888; font-size: 12px; margin-top: 1em; text-align: center; }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>ðŸ“¡ TXTCAST Viewer (Simplified Fetch)</h1>
    <div class="memo-box" id="memoDisplay">Initializing...<span class="cursor"></span></div>
    <div class="status" id="status">Connecting to Solana RPC...</div>
  </div>

  <script>
    // --- RPC Configuration ---
    // Option 1: Your own Helius RPC key (recommended for reliability)
    // const YOUR_HELIUS_RPC_KEY = "YOUR_OWN_HELIUS_API_KEY_HERE"; // Get from helius.dev
    // const RPC_URLS = [`https://mainnet.helius-rpc.com/?api-key=${YOUR_HELIUS_RPC_KEY}`];

    // Option 2: Public Solana RPC (can be rate-limited)
    // const RPC_URLS = ["https://api.mainnet-beta.solana.com"];

    // Option 3: Helius public example RPC key (use with caution, may be rate-limited)
     const RPC_URLS = ["https://mainnet.helius-rpc.com/?api-key=34ea16bb-80b2-4e57-ad72-e94ecda7028a"];


    const WALLET_ADDRESS = "9Er7ydwgEXhun5L2mHmmcjBP5qUxLYFF44PuQttNo2Sx";
    const FETCH_LIMIT_SIGS = 100; // How many signatures to fetch in each RPC call
    const MAX_SIGNATURE_PAGES = 10; // Max number of pages of signatures to fetch (FETCH_LIMIT_SIGS * MAX_SIGNATURE_PAGES = total txs scanned)
    const TYPING_SPEED_MS = 20;
    const MEMO_DISPLAY_DURATION_MS = 7000;
    const REFRESH_INTERVAL_MS = 180000; // 3 minutes

    let rpcIndex = 0;
    const walletPublicKey = new solanaWeb3.PublicKey(WALLET_ADDRESS);
    const display = document.getElementById('memoDisplay');
    const status = document.getElementById('status');
    const cursorElement = document.createElement('span');
    cursorElement.className = 'cursor';

    let currentMemos = [];
    let currentMemoIndex = 0;
    let isTyping = false;
    let displayCycleTimeoutId = null;

    const getConnection = () => {
        const activeRpcUrl = RPC_URLS[rpcIndex % RPC_URLS.length];
        console.log(`[Connection] Using RPC: ${activeRpcUrl.split('?')[0]}`);
        return new solanaWeb3.Connection(activeRpcUrl, "confirmed");
    };

    async function fetchTXTCASTMemosSimplified() {
        const connection = getConnection();
        if (!connection) {
            console.error("[FetchSimplified] No connection object.");
            return [];
        }

        console.log(`[FetchSimplified] Starting fetch for wallet: ${WALLET_ADDRESS}`);
        const allFoundMemos = new Set(); // Use a Set to automatically handle duplicates
        let beforeSig = null;
        let pagesFetched = 0;

        try {
            while (pagesFetched < MAX_SIGNATURE_PAGES) {
                const options = { limit: FETCH_LIMIT_SIGS };
                if (beforeSig) {
                    options.before = beforeSig;
                }
                console.log(`[FetchSimplified] Fetching signatures page ${pagesFetched + 1}, before: ${beforeSig || 'N/A'}`);

                const signaturesInfo = await connection.getSignaturesForAddress(walletPublicKey, options);

                if (!signaturesInfo || signaturesInfo.length === 0) {
                    console.log(`[FetchSimplified] No more signatures found on page ${pagesFetched + 1}.`);
                    break; // No more signatures for this address
                }
                console.log(`[FetchSimplified] Found ${signaturesInfo.length} signatures on page ${pagesFetched + 1}.`);

                // Process these signatures to get transactions and look for memos
                for (let i = 0; i < signaturesInfo.length; i++) {
                    const sigInfo = signaturesInfo[i];
                    console.log(`[FetchSimplified] Processing signature ${i+1}/${signaturesInfo.length}: ${sigInfo.signature}`);
                    try {
                        const tx = await connection.getParsedTransaction(sigInfo.signature, {
                            commitment: "confirmed",
                            maxSupportedTransactionVersion: 0
                        });

                        if (!tx || !tx.transaction || !tx.transaction.message) {
                            console.warn(`[FetchSimplified] Could not get parsed tx or tx.transaction.message for ${sigInfo.signature}`);
                            continue;
                        }

                        const instructions = [
                            ...(tx.transaction.message.instructions || []),
                            ...((tx.meta?.innerInstructions || []).flatMap(instr => instr.instructions) || [])
                        ];

                        for (const ix of instructions) {
                            let memoData = "";
                            // Standard Parsed Memo
                            if (ix.parsed && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
                                memoData = ix.parsed.info.memo;
                            }
                            // SPL Memo Program (raw data)
                            else if (ix.programId && ix.programId.toString() === 'MemoSq4gqABAXKb96qnH8TysNcVtrp5GcC9YGN9qET9' && ix.data) {
                                try {
                                    memoData = new TextDecoder().decode(solanaWeb3.utils.bytes.bs58.decode(ix.data));
                                } catch (e) {
                                    console.warn(`[FetchSimplified] Error decoding SPL Memo data for ${sigInfo.signature}:`, e.message);
                                }
                            }

                            if (memoData && /^TXTCAST/i.test(memoData.trim())) {
                                const finalMemo = memoData.trim();
                                console.log(`[FetchSimplified] TXTCAST Found: "${finalMemo.substring(0,50)}..." in tx ${sigInfo.signature}`);
                                allFoundMemos.add(finalMemo);
                                break; // Assuming one TXTCAST per transaction is sufficient
                            }
                        }
                    } catch (txError) {
                        console.error(`[FetchSimplified] Error processing transaction ${sigInfo.signature}:`, txError.message, txError.stack);
                        if (txError.message.includes("429") || txError.message.toLowerCase().includes("rate limit")) {
                            console.warn("[FetchSimplified] Hit rate limit. Consider using a private RPC or reducing fetch frequency.");
                            // Potentially break or switch RPC here if this happens often
                        }
                    }
                     // Optional: Add a small delay between getParsedTransaction calls if using a public RPC
                     // await new Promise(resolve => setTimeout(resolve, 50));
                }

                beforeSig = signaturesInfo[signaturesInfo.length - 1].signature;
                pagesFetched++;

                if (signaturesInfo.length < FETCH_LIMIT_SIGS) {
                    console.log("[FetchSimplified] Last page of signatures reached (less than limit).");
                    break; // Last page
                }
            } // end while loop for pages

            console.log(`[FetchSimplified] Finished fetching. Total unique TXTCAST memos found: ${allFoundMemos.size}`);
            return Array.from(allFoundMemos).reverse(); // Newest found first, then reverse for oldest display first

        } catch (error) {
            console.error(`[FetchSimplified] Major error during signature fetching for ${RPC_URLS[rpcIndex % RPC_URLS.length].split('?')[0]}:`, error.message, error.stack);
            rpcIndex = (rpcIndex + 1) % RPC_URLS.length; // Try next RPC
            status.textContent = `RPC Error. Trying next RPC: ${RPC_URLS[rpcIndex % RPC_URLS.length].split('?')[0]}...`;
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait a bit before retrying
            return fetchTXTCASTMemosSimplified(); // Recursive call to try next RPC
        }
    }

    async function typeText(element, text) {
      element.innerHTML = "";
      for (let i = 0; i < text.length; i++) {
        element.innerHTML += text[i];
        element.appendChild(cursorElement);
        await new Promise(r => setTimeout(r, TYPING_SPEED_MS));
      }
      if (cursorElement.parentNode === element) element.removeChild(cursorElement);
    }

    async function cycleMemos() {
      if (isTyping) return;
      if (currentMemos.length === 0) {
        display.innerHTML = "No TXTCAST memos found to display.";
        if (cursorElement.parentNode === display) display.removeChild(cursorElement);
        displayCycleTimeoutId = setTimeout(cycleMemos, MEMO_DISPLAY_DURATION_MS);
        return;
      }
      isTyping = true;
      const memoToDisplay = currentMemos[currentMemoIndex];
      status.textContent = `ðŸ“¡ Displaying memo ${currentMemoIndex + 1} of ${currentMemos.length}`;
      await typeText(display, memoToDisplay);
      currentMemoIndex = (currentMemoIndex + 1) % currentMemos.length;
      isTyping = false;
      displayCycleTimeoutId = setTimeout(cycleMemos, MEMO_DISPLAY_DURATION_MS);
    }

    async function updateAndDisplayMemos() {
      console.log("[UpdateCycle] Starting simplified update...");
      status.textContent = "ðŸ”„ Fetching latest TXTCAST memos (simplified)...";
      if (!isTyping) {
          display.innerHTML = "âŒ› Loading memos...";
          display.appendChild(cursorElement);
      }
      if (displayCycleTimeoutId) {
        clearTimeout(displayCycleTimeoutId);
        displayCycleTimeoutId = null;
      }

      const fetchedNewMemos = await fetchTXTCASTMemosSimplified();

      if (fetchedNewMemos && fetchedNewMemos.length > 0) {
        currentMemos = fetchedNewMemos;
        if (currentMemoIndex >= currentMemos.length) currentMemoIndex = 0;
        status.textContent = `âœ… ${currentMemos.length} TXTCAST memos ready (simplified).`;
        console.log(`[UpdateCycle] ${currentMemos.length} memos loaded. First: ${currentMemos[0]?.substring(0,50)}...`);
      } else if (currentMemos.length === 0) {
        status.textContent = "âœ… Connected â€” No TXTCAST memos found yet (simplified).";
        display.innerHTML = "No TXTCAST memos found.";
        console.log("[UpdateCycle] No memos found (simplified).");
        if (cursorElement.parentNode === display) display.removeChild(cursorElement);
      } else {
         status.textContent = `âœ… ${currentMemos.length} memos kept. No new TXTCAST memos this cycle (simplified).`;
         console.log("[UpdateCycle] No new memos, keeping old (simplified).");
      }
      isTyping = false;
      cycleMemos();
    }

    // --- Initial Load ---
    if (!RPC_URLS || RPC_URLS.length === 0 || RPC_URLS.every(url => url.includes("YOUR_"))) {
        status.textContent = "ERROR: No valid RPC URLs configured. Edit script.";
        display.innerHTML = "RPC Configuration Error";
    } else {
        console.log("Starting TXTCAST Viewer with simplified fetch.");
        updateAndDisplayMemos();
        setInterval(updateAndDisplayMemos, REFRESH_INTERVAL_MS);
    }
  </script>
</body>
</html>
